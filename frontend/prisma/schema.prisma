generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                 String              @id @default(cuid())
  name               String?
  email              String?             @unique
  emailVerified      DateTime?
  image              String?
  passwordHash       String?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  hasUsedTrial       Boolean             @default(false)
  isSubscribed       Boolean             @default(false)
  lastPaymentDate    DateTime?
  paymentId          String?             @unique
  subscriptionEnds   DateTime?
  subscriptionId     String?             @unique
  subscriptionPlan   String?
  aiAgents           AIAgent[]
  aiPracticeSessions AIPracticeSession[]
  accounts           Account[]
  payments           Payment[]
  practiceSessions   PracticeSession[]
  sessions           Session[]
  studyStreaks       StudyStreak[]
  achievements       UserAchievement[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model AIAgent {
  id               String              @id @default(cuid())
  userId           String
  name             String
  subject          String
  description      String?
  status           AgentStatus         @default(ACTIVE)
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
  lastUsed         DateTime            @default(now())
  user             User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  practiceSessions AIPracticeSession[]
  questions        AIQuestion[]
  documents        Document[]
  conversations    Conversation[]
}

model Document {
  id           String          @id @default(cuid())
  agentId      String
  fileName     String
  originalName String
  fileSize     Int
  fileType     String
  filePath     String
  status       DocumentStatus  @default(PROCESSING)
  processedAt  DateTime?
  createdAt    DateTime        @default(now())
  questions    AIQuestion[]
  agent        AIAgent         @relation(fields: [agentId], references: [id], onDelete: Cascade)
  chunks       DocumentChunk[]
}

model DocumentChunk {
  id         String            @id @default(cuid())
  documentId String
  content    String
  pageNumber Int?
  chunkIndex Int
  metadata   Json?
  createdAt  DateTime          @default(now())
  document   Document          @relation(fields: [documentId], references: [id], onDelete: Cascade)
  vectors    VectorEmbedding[]
}

model VectorEmbedding {
  id        String                @id @default(cuid())
  chunkId   String
  embedding Unsupported("vector")
  model     String                @default("text-embedding-004")
  createdAt DateTime              @default(now())
  chunk     DocumentChunk         @relation(fields: [chunkId], references: [id], onDelete: Cascade)
}

model AIQuestion {
  id                 String                      @id @default(cuid())
  agentId            String
  documentId         String?
  questionText       String
  questionType       AIQuestionType
  difficulty         Difficulty
  options            String[]
  correctAnswer      String
  explanation        String?
  expectedAnswer     String?
  keyPoints          String[]
  evaluationCriteria String[]
  centralConcept     String?
  expectedBranches   String[]
  metadata           Json?
  createdAt          DateTime                    @default(now())
  practiceSessions   AIPracticeSessionQuestion[]
  agent              AIAgent                     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  document           Document?                   @relation(fields: [documentId], references: [id])
}

model AIPracticeSession {
  id             String                      @id @default(cuid())
  userId         String
  agentId        String
  sessionName    String
  totalQuestions Int
  correctAnswers Int
  score          Float
  timeSpent      Int
  completedAt    DateTime                    @default(now())
  createdAt      DateTime                    @default(now())
  agent          AIAgent                     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  user           User                        @relation(fields: [userId], references: [id], onDelete: Cascade)
  questions      AIPracticeSessionQuestion[]
}

model AIPracticeSessionQuestion {
  id                String            @id @default(cuid())
  practiceSessionId String
  questionId        String
  userAnswer        String?
  isCorrect         Boolean?
  timeSpent         Int
  answeredAt        DateTime          @default(now())
  practiceSession   AIPracticeSession @relation(fields: [practiceSessionId], references: [id], onDelete: Cascade)
  question          AIQuestion        @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([practiceSessionId, questionId])
}

model ExamCategory {
  id               String            @id @default(cuid())
  name             String            @unique
  description      String?
  icon             String?
  color            String?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  practiceSessions PracticeSession[]
  questions        Question[]
}

model Question {
  id               String                    @id @default(cuid())
  examCategoryId   String
  questionText     String
  questionType     QuestionType
  difficulty       Difficulty
  options          String[]
  correctAnswer    String
  explanation      String?
  tags             String[]
  createdAt        DateTime                  @default(now())
  updatedAt        DateTime                  @updatedAt
  practiceSessions PracticeSessionQuestion[]
  examCategory     ExamCategory              @relation(fields: [examCategoryId], references: [id], onDelete: Cascade)
}

model PracticeSession {
  id             String                    @id @default(cuid())
  userId         String
  examCategoryId String
  sessionName    String
  totalQuestions Int
  correctAnswers Int
  score          Float
  timeSpent      Int
  completedAt    DateTime                  @default(now())
  createdAt      DateTime                  @default(now())
  examCategory   ExamCategory              @relation(fields: [examCategoryId], references: [id], onDelete: Cascade)
  user           User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  questions      PracticeSessionQuestion[]
}

model PracticeSessionQuestion {
  id                String          @id @default(cuid())
  practiceSessionId String
  questionId        String
  userAnswer        String?
  isCorrect         Boolean
  timeSpent         Int
  answeredAt        DateTime        @default(now())
  practiceSession   PracticeSession @relation(fields: [practiceSessionId], references: [id], onDelete: Cascade)
  question          Question        @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([practiceSessionId, questionId])
}

model Achievement {
  id               String            @id @default(cuid())
  name             String            @unique
  description      String
  icon             String
  criteria         String
  points           Int
  createdAt        DateTime          @default(now())
  userAchievements UserAchievement[]
}

model UserAchievement {
  id            String      @id @default(cuid())
  userId        String
  achievementId String
  earnedAt      DateTime    @default(now())
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
}

model StudyStreak {
  id        String    @id @default(cuid())
  userId    String
  startDate DateTime
  endDate   DateTime?
  daysCount Int
  isActive  Boolean   @default(true)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Payment {
  id             String        @id @default(cuid())
  userId         String
  razorpayId     String        @unique
  amount         Int
  currency       String        @default("INR")
  status         PaymentStatus
  plan           String
  subscriptionId String?       @unique
  paymentMethod  String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum QuestionType {
  MULTIPLE_CHOICE
  SINGLE_CHOICE
  TRUE_FALSE
  FILL_IN_THE_BLANK
  ESSAY
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
  EXPERT
}

enum AIQuestionType {
  MCQ
  OBJECTIVE
  MINDMAP
  SHORT_ANSWER
  ESSAY
}

enum AgentStatus {
  ACTIVE
  INACTIVE
  PROCESSING
  ERROR
}

enum DocumentStatus {
  PROCESSING
  PROCESSED
  ERROR
  DELETED
}

enum PaymentStatus {
  PENDING
  CAPTURED
  FAILED
  CANCELLED
  REFUNDED
}

model Conversation {
  id        String                @id @default(cuid())
  agentId   String
  title     String?
  createdAt DateTime              @default(now())
  updatedAt DateTime              @updatedAt
  agent     AIAgent               @relation(fields: [agentId], references: [id], onDelete: Cascade)
  messages  ConversationMessage[]
}

model ConversationMessage {
  id             String       @id @default(cuid())
  conversationId String
  role           MessageRole
  content        String
  sources        Json? // Store sources as JSON for RAG responses
  metadata       Json? // Store additional metadata like similarity scores
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
}

enum MessageRole {
  USER
  ASSISTANT
}
