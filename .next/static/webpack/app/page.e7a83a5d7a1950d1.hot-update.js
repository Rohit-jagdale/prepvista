"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: function() { return /* binding */ api; }\n/* harmony export */ });\n/* harmony import */ var _config_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/api */ \"(app-pages-browser)/./config/api.ts\");\n// API configuration and utility functions\n\nconst API_BASE_URL = _config_api__WEBPACK_IMPORTED_MODULE_0__.API_CONFIG.BACKEND_URL;\nconst api = {\n    baseUrl: API_BASE_URL,\n    // Create a new practice session with 10 questions\n    createSession: async function(examType, topic) {\n        let difficulty = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"medium\";\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/session\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                exam_type: examType,\n                topic,\n                difficulty\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to create session: \".concat(response.statusText));\n        }\n        return response.json();\n    },\n    // Submit an answer for a question\n    submitAnswer: async (sessionId, questionId, selectedAnswer, timeTaken)=>{\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/session/\").concat(sessionId, \"/answer\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                session_id: sessionId,\n                question_id: questionId,\n                selected_answer: selectedAnswer,\n                time_taken: timeTaken\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to submit answer: \".concat(response.statusText));\n        }\n        return response.json();\n    },\n    // Complete the session and get results\n    completeSession: async (sessionId)=>{\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/session/\").concat(sessionId, \"/complete\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to complete session: \".concat(response.statusText));\n        }\n        return response.json();\n    },\n    // Get session status\n    getSessionStatus: async (sessionId)=>{\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/session/\").concat(sessionId, \"/status\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to get session status: \".concat(response.statusText));\n        }\n        return response.json();\n    },\n    // Generate questions (legacy - kept for backward compatibility)\n    generateQuestions: async function(examType, topic) {\n        let difficulty = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"medium\", count = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10;\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/questions\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                exam_type: examType,\n                topic,\n                difficulty,\n                count\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to generate questions: \".concat(response.statusText));\n        }\n        return response.json();\n    },\n    // Generate feedback (legacy - kept for backward compatibility)\n    generateFeedback: async (examType, topic, question, userAnswer, correctAnswer, isCorrect)=>{\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/feedback\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                exam_type: examType,\n                topic,\n                question,\n                user_answer: userAnswer,\n                correct_answer: correctAnswer,\n                is_correct: isCorrect\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to generate feedback: \".concat(response.statusText));\n        }\n        return response.json();\n    },\n    // Get exam types\n    getExamTypes: async ()=>{\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/exam-types\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to get exam types: \".concat(response.statusText));\n        }\n        return response.json();\n    },\n    // Get topics for exam type\n    getTopics: async (examType)=>{\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/topics/\").concat(examType));\n        if (!response.ok) {\n            throw new Error(\"Failed to get topics: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQzNEVSxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ1AsZ0JBQWdCO1lBQ2xCO1lBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztnQkFDbkJDLFdBQVdWO2dCQUNYQztnQkFDQTRCO2dCQUNBSSxhQUFhSDtnQkFDYkksZ0JBQWdCSDtnQkFDaEJJLFlBQVlIO1lBQ2Q7UUFDRjtRQUVBLElBQUksQ0FBQzdCLFNBQVNRLEVBQUUsRUFBRTtZQUNoQixNQUFNLElBQUlDLE1BQU0sZ0NBQW9ELE9BQXBCVCxTQUFTVSxVQUFVO1FBQ3JFO1FBRUEsT0FBT1YsU0FBU1csSUFBSTtJQUN0QjtJQUVBLGlCQUFpQjtJQUNqQnNCLGNBQWM7UUFDWixNQUFNakMsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJULGNBQWE7UUFFN0MsSUFBSSxDQUFDUSxTQUFTUSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJQyxNQUFNLDZCQUFpRCxPQUFwQlQsU0FBU1UsVUFBVTtRQUNsRTtRQUVBLE9BQU9WLFNBQVNXLElBQUk7SUFDdEI7SUFFQSwyQkFBMkI7SUFDM0J1QixXQUFXLE9BQU9yQztRQUNoQixNQUFNRyxXQUFXLE1BQU1DLE1BQU0sR0FBOEJKLE9BQTNCTCxjQUFhLGdCQUF1QixPQUFUSztRQUUzRCxJQUFJLENBQUNHLFNBQVNRLEVBQUUsRUFBRTtZQUNoQixNQUFNLElBQUlDLE1BQU0seUJBQTZDLE9BQXBCVCxTQUFTVSxVQUFVO1FBQzlEO1FBRUEsT0FBT1YsU0FBU1csSUFBSTtJQUN0QjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FwaS50cz82OGExIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFQSSBjb25maWd1cmF0aW9uIGFuZCB1dGlsaXR5IGZ1bmN0aW9uc1xuaW1wb3J0IHsgQVBJX0NPTkZJRyB9IGZyb20gJy4uL2NvbmZpZy9hcGknO1xuXG5jb25zdCBBUElfQkFTRV9VUkwgPSBBUElfQ09ORklHLkJBQ0tFTkRfVVJMO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb25SZXNwb25zZSB7XG4gIHNlc3Npb25faWQ6IHN0cmluZztcbiAgcXVlc3Rpb25zOiBRdWVzdGlvbltdO1xuICB0aW1lX2xpbWl0OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvblJlc3VsdCB7XG4gIHNlc3Npb25faWQ6IHN0cmluZztcbiAgdG90YWxfcXVlc3Rpb25zOiBudW1iZXI7XG4gIGNvcnJlY3RfYW5zd2VyczogbnVtYmVyO1xuICBzY29yZV9wZXJjZW50YWdlOiBudW1iZXI7XG4gIHRpbWVfdGFrZW46IG51bWJlcjtcbiAgd3JvbmdfYW5zd2VyczogV3JvbmdBbnN3ZXJbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXcm9uZ0Fuc3dlciB7XG4gIHF1ZXN0aW9uX2lkOiBzdHJpbmc7XG4gIHF1ZXN0aW9uOiBzdHJpbmc7XG4gIHVzZXJfYW5zd2VyOiBzdHJpbmc7XG4gIGNvcnJlY3RfYW5zd2VyOiBzdHJpbmc7XG4gIG9wdGlvbnM6IHN0cmluZ1tdO1xuICBleHBsYW5hdGlvbjogc3RyaW5nO1xuICBzaG9ydGN1dDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXN0aW9uIHtcbiAgaWQ6IHN0cmluZztcbiAgcXVlc3Rpb246IHN0cmluZztcbiAgb3B0aW9uczogc3RyaW5nW107XG4gIGNvcnJlY3RfYW5zd2VyOiBudW1iZXI7XG4gIGV4cGxhbmF0aW9uOiBzdHJpbmc7XG4gIHNob3J0Y3V0OiBzdHJpbmc7XG4gIGRpZmZpY3VsdHk6IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGFwaSA9IHtcbiAgYmFzZVVybDogQVBJX0JBU0VfVVJMLFxuICBcbiAgLy8gQ3JlYXRlIGEgbmV3IHByYWN0aWNlIHNlc3Npb24gd2l0aCAxMCBxdWVzdGlvbnNcbiAgY3JlYXRlU2Vzc2lvbjogYXN5bmMgKGV4YW1UeXBlOiBzdHJpbmcsIHRvcGljOiBzdHJpbmcsIGRpZmZpY3VsdHk6IHN0cmluZyA9ICdtZWRpdW0nKTogUHJvbWlzZTxTZXNzaW9uUmVzcG9uc2U+ID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Nlc3Npb25gLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGV4YW1fdHlwZTogZXhhbVR5cGUsXG4gICAgICAgIHRvcGljLFxuICAgICAgICBkaWZmaWN1bHR5LFxuICAgICAgfSksXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHNlc3Npb246ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSxcbiAgXG4gIC8vIFN1Ym1pdCBhbiBhbnN3ZXIgZm9yIGEgcXVlc3Rpb25cbiAgc3VibWl0QW5zd2VyOiBhc3luYyAoc2Vzc2lvbklkOiBzdHJpbmcsIHF1ZXN0aW9uSWQ6IHN0cmluZywgc2VsZWN0ZWRBbnN3ZXI6IG51bWJlciwgdGltZVRha2VuOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Nlc3Npb24vJHtzZXNzaW9uSWR9L2Fuc3dlcmAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgc2Vzc2lvbl9pZDogc2Vzc2lvbklkLFxuICAgICAgICBxdWVzdGlvbl9pZDogcXVlc3Rpb25JZCxcbiAgICAgICAgc2VsZWN0ZWRfYW5zd2VyOiBzZWxlY3RlZEFuc3dlcixcbiAgICAgICAgdGltZV90YWtlbjogdGltZVRha2VuLFxuICAgICAgfSksXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3VibWl0IGFuc3dlcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9LFxuICBcbiAgLy8gQ29tcGxldGUgdGhlIHNlc3Npb24gYW5kIGdldCByZXN1bHRzXG4gIGNvbXBsZXRlU2Vzc2lvbjogYXN5bmMgKHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTxTZXNzaW9uUmVzdWx0PiA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9zZXNzaW9uLyR7c2Vzc2lvbklkfS9jb21wbGV0ZWAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjb21wbGV0ZSBzZXNzaW9uOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0sXG4gIFxuICAvLyBHZXQgc2Vzc2lvbiBzdGF0dXNcbiAgZ2V0U2Vzc2lvblN0YXR1czogYXN5bmMgKHNlc3Npb25JZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9zZXNzaW9uLyR7c2Vzc2lvbklkfS9zdGF0dXNgKTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgc2Vzc2lvbiBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSxcbiAgXG4gIC8vIEdlbmVyYXRlIHF1ZXN0aW9ucyAobGVnYWN5IC0ga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgZ2VuZXJhdGVRdWVzdGlvbnM6IGFzeW5jIChleGFtVHlwZTogc3RyaW5nLCB0b3BpYzogc3RyaW5nLCBkaWZmaWN1bHR5OiBzdHJpbmcgPSAnbWVkaXVtJywgY291bnQ6IG51bWJlciA9IDEwKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9xdWVzdGlvbnNgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGV4YW1fdHlwZTogZXhhbVR5cGUsXG4gICAgICAgIHRvcGljLFxuICAgICAgICBkaWZmaWN1bHR5LFxuICAgICAgICBjb3VudCxcbiAgICAgIH0pLFxuICAgIH0pO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdlbmVyYXRlIHF1ZXN0aW9uczogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9LFxuICBcbiAgLy8gR2VuZXJhdGUgZmVlZGJhY2sgKGxlZ2FjeSAtIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gIGdlbmVyYXRlRmVlZGJhY2s6IGFzeW5jIChleGFtVHlwZTogc3RyaW5nLCB0b3BpYzogc3RyaW5nLCBxdWVzdGlvbjogc3RyaW5nLCB1c2VyQW5zd2VyOiBzdHJpbmcsIGNvcnJlY3RBbnN3ZXI6IHN0cmluZywgaXNDb3JyZWN0OiBib29sZWFuKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9mZWVkYmFja2AsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZXhhbV90eXBlOiBleGFtVHlwZSxcbiAgICAgICAgdG9waWMsXG4gICAgICAgIHF1ZXN0aW9uLFxuICAgICAgICB1c2VyX2Fuc3dlcjogdXNlckFuc3dlcixcbiAgICAgICAgY29ycmVjdF9hbnN3ZXI6IGNvcnJlY3RBbnN3ZXIsXG4gICAgICAgIGlzX2NvcnJlY3Q6IGlzQ29ycmVjdCxcbiAgICAgIH0pLFxuICAgIH0pO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdlbmVyYXRlIGZlZWRiYWNrOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0sXG4gIFxuICAvLyBHZXQgZXhhbSB0eXBlc1xuICBnZXRFeGFtVHlwZXM6IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2V4YW0tdHlwZXNgKTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgZXhhbSB0eXBlczogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9LFxuICBcbiAgLy8gR2V0IHRvcGljcyBmb3IgZXhhbSB0eXBlXG4gIGdldFRvcGljczogYXN5bmMgKGV4YW1UeXBlOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3RvcGljcy8ke2V4YW1UeXBlfWApO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB0b3BpY3M6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSxcbn07XG4iXSwibmFtZXMiOlsiQVBJX0NPTkZJRyIsIkFQSV9CQVNFX1VSTCIsIkJBQ0tFTkRfVVJMIiwiYXBpIiwiYmFzZVVybCIsImNyZWF0ZVNlc3Npb24iLCJleGFtVHlwZSIsInRvcGljIiwiZGlmZmljdWx0eSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJleGFtX3R5cGUiLCJvayIsIkVycm9yIiwic3RhdHVzVGV4dCIsImpzb24iLCJzdWJtaXRBbnN3ZXIiLCJzZXNzaW9uSWQiLCJxdWVzdGlvbklkIiwic2VsZWN0ZWRBbnN3ZXIiLCJ0aW1lVGFrZW4iLCJzZXNzaW9uX2lkIiwicXVlc3Rpb25faWQiLCJzZWxlY3RlZF9hbnN3ZXIiLCJ0aW1lX3Rha2VuIiwiY29tcGxldGVTZXNzaW9uIiwiZ2V0U2Vzc2lvblN0YXR1cyIsImdlbmVyYXRlUXVlc3Rpb25zIiwiY291bnQiLCJnZW5lcmF0ZUZlZWRiYWNrIiwicXVlc3Rpb24iLCJ1c2VyQW5zd2VyIiwiY29ycmVjdEFuc3dlciIsImlzQ29ycmVjdCIsInVzZXJfYW5zd2VyIiwiY29ycmVjdF9hbnN3ZXIiLCJpc19jb3JyZWN0IiwiZ2V0RXhhbVR5cGVzIiwiZ2V0VG9waWNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});